#!/usr/bin/env python
from __future__ import print_function

import argparse
import dxpy
import fnmatch
import json
import pprint
import os
import subprocess
import sys
import time

top_dir = os.path.dirname(sys.argv[0])
version_id = None
asset_id = None
project_id = None
lib_object_ids = None
required_libs = ["dnanexus-api-0.1.0-SNAPSHOT-jar-with-dependencies.jar",
                 "dxWDL.jar"]

def main():
    argparser = argparse.ArgumentParser(description="compiler from WDL to dnanexus")
    argparser.add_argument("command", choices=["compile"], help="command to issue to dxWDL")
    argparser.add_argument("wdl_file", help="WDL workflow file")
    argparser.add_argument("--asset", help="Override configuration file asset Id")
    argparser.add_argument("--destination", help="Output folder for workflow")
    argparser.add_argument("--mode", help="Compilation mode, a debugging flag")
    argparser.add_argument("--verbose", dest='verbose', action='store_true', default=False,
                           help="Print detailed progress reports")
    argparser.add_argument("--force", dest='force', action='store_true', default=False,
                           help="Always rebuild applets")
    args = argparser.parse_args()

    if args.command == "compile":
        cmd_compile(args)
    else:
        print("Unknown command {}".format(args.command), file=sys.stderr)
        exit(1)

def cmd_compile(args):
    global asset_id
    global version_id

    # Where should we write the result?
    if args.destination is None:
        destination = dxpy.config.get('DX_CLI_WD', u'/')
    else:
        destination = args.destination

    # Figure out the asset ID
    if args.asset is not None:
        asset_id = args.asset
    if asset_id is None:
        print("Asset ID is undefined", file=sys.stderr)
        exit(1)

    jars = construct_java_classpath()
    classpath = ":".join(jars)

    if version_id is not None:
        version_id = version_id.strip()
        validate_library_version(version_id, classpath)
        validate_asset_version(version_id, asset_id)
    compile_workflow(args.wdl_file, destination, asset_id, classpath, args.force, args.verbose, args.mode)


# Check if the local library has the correct version
def validate_library_version(version_id, classpath):
    cmd_line = ["java", "-cp", classpath, "dxWDL.Main", "version"]
    outstr = subprocess.check_output(cmd_line)
    lib_version_id = outstr.rstrip().split('\n')[-1].strip()
    if lib_version_id != version_id:
        print("Local jar files have incorrect version {}, should be {}".
              format(lib_version_id, version_id), file=sys.stderr)
        print("Please remove the local jar files, and rerun dxWDL.", file=sys.stderr)
        print("It will download the correct version from the platform.", file=sys.stderr)
        exit(1)

# Make sure the asset we point to, has the correct version
def validate_asset_version(version_id, asset_id):
    record = dxpy.DXRecord(asset_id)
    desc = record.describe(incl_properties=True)
    props = desc["properties"]
    pkg_version_id = props["version"].strip()
    if version_id == pkg_version_id:
        print("version={}".format(version_id), file=sys.stderr)
    else:
        print("Asset version number mismatch, local={}, platform={}".format(version_id, pkg_version_id))
        exit(1)

# Build a workflow.
#
# wf             workflow name
# classpath      java classpath needed for running compilation
# destination    output path on the platform
#
# return --      workflow ID
def compile_workflow(wf_file, destination, asset_id, classpath, force, verbose, mode):
    print("Compiling {}".format(wf_file), file=sys.stderr)
    cmd_line = [
        "java", "-cp", classpath, "dxWDL.Main", "compile", wf_file,
        "-o", destination,
        "-asset", asset_id
    ]
    if version_id is not None:
        cmd_line += ["-expected_version", version_id]
    if force:
        cmd_line += ["-force"]
    if verbose:
        cmd_line += ["-verbose"]
    if mode:
        cmd_line += ["-mode", mode]

    print((" ".join(cmd_line)), file=sys.stderr)

    # Call java/scala dxWDL compiler, and pipe stdout/stderr
    outstr = subprocess.check_output(cmd_line)
    retval = outstr.rstrip().split('\n')[-1]
    return retval


# Search for the jars locally. If not found, download
# from the platform.
def construct_java_classpath():
    classpath = lookup_local_jars()
    if classpath is not None:
        return classpath
    download_libs()
    classpath = lookup_local_jars()
    if classpath is None:
        print("Error, could not find jars, after download", file=sys.stderr)
        exit(1)
    return classpath

# Download libraries from the platform
def download_libs():
    if (lib_object_ids is None or
        len(lib_object_ids) == 0):
        print("Can't download libraries, download objects are not set", file=sys.stderr)
        exit(1)

    # We don't have all jars locally. Download them from the platform.
    for fid in lib_object_ids:
        dxfile = dxpy.DXFile(fid, project=project_id)
        name = dxfile.describe()["name"]
        print("downloading {}".format(name), file=sys.stderr)
        dxpy.download_dxfile(fid, os.path.join(top_dir, name))

def lookup_local_jars():
    [jar_names, jar_paths] = find('*.jar', top_dir)
    print("found {}".format(jar_names), file=sys.stderr)
    classpath = []
    for lib in required_libs:
        if lib in jar_names:
            index = jar_names.index(lib)
            classpath.append(jar_paths[index])
        else:
            print("Not found {}".format(lib), file=sys.stderr)
            return None
    return classpath

# Find all files that match regular expression [pattern]
# starting from [path]
def find(pattern, path):
    names = []
    paths = []
    for root, dirs, files in os.walk(path):
        for name in files:
            if fnmatch.fnmatch(name, pattern):
                names.append(name)
                paths.append(os.path.join(root, name))
    return [names, paths]

if __name__ == '__main__':
    main()
